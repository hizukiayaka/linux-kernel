
#ifndef SAMSUNG_HDMI_H
#define SAMSUNG_HDMI_H

#include <media/v4l2-subdev.h>
#include <media/v4l2-common.h>
#include <media/v4l2-dev.h>
#include <media/v4l2-device.h>
#include <linux/switch.h>
#include <mach/videodev2_samsung.h>
#include <mach/dev.h>

struct hdmi_tg_regs {
	u8 cmd;
	u8 h_fsz_l;
	u8 h_fsz_h;
	u8 hact_st_l;
	u8 hact_st_h;
	u8 hact_sz_l;
	u8 hact_sz_h;
	u8 v_fsz_l;
	u8 v_fsz_h;
	u8 vsync_l;
	u8 vsync_h;
	u8 vsync2_l;
	u8 vsync2_h;
	u8 vact_st_l;
	u8 vact_st_h;
	u8 vact_sz_l;
	u8 vact_sz_h;
	u8 field_chg_l;
	u8 field_chg_h;
	u8 vact_st2_l;
	u8 vact_st2_h;
	u8 vact_st3_l;
	u8 vact_st3_h;
	u8 vact_st4_l;
	u8 vact_st4_h;
	u8 vsync_top_hdmi_l;
	u8 vsync_top_hdmi_h;
	u8 vsync_bot_hdmi_l;
	u8 vsync_bot_hdmi_h;
	u8 field_top_hdmi_l;
	u8 field_top_hdmi_h;
	u8 field_bot_hdmi_l;
	u8 field_bot_hdmi_h;
	u8 tg_3d;
};


struct hdmi_core_regs {
	u8 h_blank[2];
	u8 v2_blank[2];
	u8 v1_blank[2];
	u8 v_line[2];
	u8 h_line[2];
	u8 hsync_pol[1];
	u8 vsync_pol[1];
	u8 int_pro_mode[1];
	u8 v_blank_f0[2];
	u8 v_blank_f1[2];
	u8 h_sync_start[2];
	u8 h_sync_end[2];
	u8 v_sync_line_bef_2[2];
	u8 v_sync_line_bef_1[2];
	u8 v_sync_line_aft_2[2];
	u8 v_sync_line_aft_1[2];
	u8 v_sync_line_aft_pxl_2[2];
	u8 v_sync_line_aft_pxl_1[2];
	u8 v_blank_f2[2]; /* for 3D mode */
	u8 v_blank_f3[2]; /* for 3D mode */
	u8 v_blank_f4[2]; /* for 3D mode */
	u8 v_blank_f5[2]; /* for 3D mode */
	u8 v_sync_line_aft_3[2];
	u8 v_sync_line_aft_4[2];
	u8 v_sync_line_aft_5[2];
	u8 v_sync_line_aft_6[2];
	u8 v_sync_line_aft_pxl_3[2];
	u8 v_sync_line_aft_pxl_4[2];
	u8 v_sync_line_aft_pxl_5[2];
	u8 v_sync_line_aft_pxl_6[2];
	u8 vact_space_1[2];
	u8 vact_space_2[2];
	u8 vact_space_3[2];
	u8 vact_space_4[2];
	u8 vact_space_5[2];
	u8 vact_space_6[2];
};

struct hdmi_preset_conf {
	struct hdmi_core_regs core;
	struct hdmi_tg_regs tg;
};


struct hdmi_resources {
	struct clk *hdmi;
	struct clk *sclk_hdmi;
	struct clk *sclk_pixel;
	struct clk *sclk_hdmiphy;
	struct clk *hdmiphy;
	struct regulator_bulk_data *regul_bulk;
	int regul_count;
};

struct hdmi_device {
	/** base address of HDMI registers */
	void __iomem *regs;
	/** HDMI interrupt */
	unsigned int irq;
	/** pointer to device parent */
	struct device *dev;
	/** subdev generated by HDMI device */
	struct v4l2_subdev sd;
	/** V4L2 device structure */
	struct v4l2_device v4l2_dev;
	/** subdev of HDMIPHY interface */
	struct v4l2_subdev *phy_sd;
	/** configuration of current graphic mode */
	const struct hdmi_preset_conf *cur_conf;
	/** flag indicating that timings are dirty */
	int cur_conf_dirty;
	/** current preset */
	u32 cur_preset;
	/** other resources */
	struct hdmi_resources res;
	/** HDMI External interrupt */
	unsigned int ext_irq;
	/** cable connection status */
	bool connected;
	/* switch indicating connected/disconnected state */
	struct switch_dev sw_connected;
	/** work queue to handle HPD events */
	struct work_struct work;
	struct i2c_client *hdmiphy_port;
	int hdcp_enabled;
        struct device *bus_dev;
};

extern bool on_stop_process;
#define hdmi_mask_8(x)		((x) & 0xFF)
#define hdmi_mask_16(x)		(((x) >> 8) & 0xFF)
#define hdmi_mask_24(x)		(((x) >> 16) & 0xFF)
#define hdmi_mask_32(x)		(((x) >> 24) & 0xFF)

#define hdmi_write_16(x, y)				\
	do {						\
		writeb(hdmi_mask_8(x), y);		\
		writeb(hdmi_mask_16(x), y + 4);		\
	} while (0);

#define hdmi_write_24(x, y)				\
	do {						\
		writeb(hdmi_mask_8(x), y);		\
		writeb(hdmi_mask_16(x), y + 4);		\
		writeb(hdmi_mask_24(x), y + 8);		\
	} while (0);

#define hdmi_write_32(x, y)				\
	do {						\
		writeb(hdmi_mask_8(x), y);		\
		writeb(hdmi_mask_16(x), y + 4);		\
		writeb(hdmi_mask_24(x), y + 8);		\
		writeb(hdmi_mask_32(x), y + 12);	\
	} while (0);

#define hdmi_write_l(buff, base, start, count)		\
	do {						\
		u8 *ptr = buff;				\
		int i = 0;				\
		int a = start;				\
		do {					\
			writeb(ptr[i], base + a);	\
			a += 4;				\
			i++;				\
		} while (i <= (count - 1));		\
	} while (0);

#define hdmi_read_l(buff, base, start, count)		\
	do {						\
		u8 *ptr = buff;				\
		int i = 0;				\
		int a = start;				\
		do {					\
			ptr[i] = readb(base + a);	\
			a += 4;				\
			i++;				\
		} while (i <= (count - 1));		\
	} while (0);

#define hdmi_bit_set(en, reg, val)			\
	do {						\
		if (en)					\
			reg |= val;			\
		else					\
			reg &= ~val;			\
	} while (0);

extern bool s5p_hdmi_ctrl_status(void);
extern int s5p_hdcp_start(struct hdmi_device *);
extern int s5p_hdcp_stop(void);
extern irqreturn_t s5p_hdcp_irq_handler(int , void *);
extern int s5p_hdcp_init(void);
#endif /* SAMSUNG_HDMI_H */
